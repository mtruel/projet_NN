Neural Network NÂ°2
==================

----------------------------
 Goal of the neural network
----------------------------

This Neural Network (NN2) aims at guessing the coordinates of the inner nodes. 
The algorithm takes as input the number of inner nodes approximated by the first neural network,
and the coordinates of the nodes of a cartesian grid that are inside the polygon.


---------------------
 Database generation
---------------------

We need to generate the same polygons as the first neural network, get the number of inner nodes 
generated by gmsh, but also their coordinates. 

^^^^^^^^^^^^^^^^^
Grid Generation
^^^^^^^^^^^^^^^^^

This second neural network works thanks to a cartesian grid of fixed scale.
The size of the elements of the grid is arbitrary, 
but should logically be smaller than the size of the smallest edge.

.. code-block:: python

    Gscale_factor = 0.1
    Gscale = Gscale_factor * ls  # size of mesh grid

The grid should first contain the entire polygon, 
thus its side size should be greater than the maximum distance between two points 
on the horizontal and vertical axis.
However, the polygon is scaled and is always contained in the unit circle. 
It is then more conveignant and faster to keep the unit size 
instead of optimizing a few hundredths every iteration.

.. figure:: images/schemaNN_grid.svg
  :width: 300
  :align: center
  :class: no-scaled-link
  :alt: Schema of the grid with a contour of 7 nodes

  Example of grid for a polygon of 7 nodes  

The grid generation is made by the ``create_grid()`` function.

^^^^^^^^^^^^^^^^^
Inner nodes
^^^^^^^^^^^^^^^^^

Once the grid is generated, we need to find the coordinates of the grid nodes 
that are inside the polygon. 
The function ``is_in_contour()`` does it by using the Even-odd rule. 
The algorithm is taken from `this python code <https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule#cite_note-3>`_.

^^^^^^^^^^^^^^^^^
Scores of nodes
^^^^^^^^^^^^^^^^^

Each grid node now has to be graded with a score defined as 
the distance to the closest mesh node. The function ``score_of_node()`` 
gives the score of a given node and ``calculate_score_array()`` 
the list of scores for each point of the grid inside the polygon.

.. figure:: images/scores_mesh_examples.png
  :width: 500
  :align: center
  :class: no-scaled-link
  :alt: score examples

  Example of scores distribution for polygons of 7 nodes. We can see the 4 nodes placed by gmsh.  

NN2 will have to return this list of scores on its own once trained given 
the coordinates of the grid points inside the polygon and the number of inner nodes.

---------------------
 Neural Network
---------------------

The NN2 takes as input the contour coordinates, the coordinates of the
grid points inside the polygon and the target edge lenght ``ls``. 
It is trained by receiving a score list for every node of the grid 
and tries to guess the scores by itself after the training.

.. figure:: images/algo_NN2.svg
  :width: 500
  :align: center
  :class: no-scaled-link
  :alt: Algorihtm of NN2

  Algorihtm of NN2. Source : Article  

The grid generation is made by the ``create_grid()`` function.

The entire grid is given to the network. 
The article :cite:`papagiannopoulos_clausen_avellan_2021`` splits the grid in multiple parts to give more data to the network.

------------------------
 Final node positioning
------------------------

Once the list of scores is guessed by the NN2, we have to guess the coordinates of the mesh nodes, and 
make an interpolation to place the nodes more precisely.

^^^^^^^^^^^^^^^^^^
Find the minimums
^^^^^^^^^^^^^^^^^^

A solution to find the nodes is made by the following algorithm: 

* Find the current node with the minimum score and mark it
* Remove all the nodes within a given radius around the marked node
* Find the new minimum and repeat

If the radius is large enough, the new minimum should be in a 
different position, and the operation can be repeated as much as there 
are inner nodes. 

.. figure:: images/radius_scores.png
  :width: 500
  :align: center
  :class: no-scaled-link
  :alt: radius examples

  Example of radius around the minimum (red point) 
  allowing the other red point to become the second minimum

In our program, the function ``remove_points_grid()`` 
removes all the points of the grid within the arbitrary radius 
with a simple condition based on the circle equation:

.. code-block:: python

    if((grid[i][0]-x)**2 + (grid[i][1]-y)**2 < radius**2):
            to_remove.append(i)
    grid = np.delete(grid, to_remove, axis=0)
    scores = np.delete(scores, to_remove)
    return grid, scores

The choice of ``radius`` is important, because a big radius implies more points 
to remove, thus more computation time, but a too small radius can misplace the points, 
like shown :numref:`error_point`.

.. _error_point:
.. figure:: images/erreur_point_r0.01_gscale0.05.png
  :width: 500
  :align: center
  :class: no-scaled-link
  :alt: radius examples

  Example of point badly placed due to a too small radius 
  (``radius = 0.01*ls`` and ``Gscale=0.05*ls``)

^^^^^^^^^^^^^^^^^^
Interpolation
^^^^^^^^^^^^^^^^^^

Once we have the position of an inner node of the mesh locked on the grid, 
we choose to interpolate the scores of the grid points around this inner node
to place it more accurately out of the grid constraint.

.. figure:: images/interpolation.svg
  :width: 400
  :align: center
  :class: no-scaled-link
  :alt: interpolation schema

  Simple schema of how the final node (red) is interpolated 
  from the scores around the minimum (center)

This interpolation is made by the function ``place_inner_vertex()``.
The interpolation is simple to implement with barycentric coordinates, 
but one has to know the index of the 8 nodes surrounding the minimum score node. 
The hardest part is to find the index of the nodes directly above and below the 
center node. In order to find these, we need to go through each node of the grid 
and look for the two nodes with the same x-coordinate as the center node 
and a y-coordinate close enough (distance of a square of the grid) 
to the center node y-coordinate. Then, the 6 other nodes index are easy to 
find, by addind or subtracting 1 to the index of the two nodes.

.. code-block:: python

    for i in range(len(grid)):
        if grid[i][0] == coord_min[0]:
            if abs(grid[i][1]-coord_min[1]) <= 1.1*Gscale:
                local_domain_label.append(i-1)
                local_domain_label.append(i)
                local_domain_label.append(i+1)

This function returns this kind of results:

.. figure:: images/interpolation_final_zoom.png
  :width: 800
  :align: center
  :class: no-scaled-link
  :alt: results of the interpolation

  Result of the interpolation of 11 nodes for a polygon of 10 sides
